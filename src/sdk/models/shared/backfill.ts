/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SpeakeasyBase, SpeakeasyMetadata } from "../../../internal/utils";
import { Expose, Transform } from "class-transformer";

/**
 * The status of the backfill.
 */
export enum BackfillStatus {
    Pending = "pending",
    Reflected = "reflected",
    PendingRevert = "pending_revert",
    Reverted = "reverted",
}

/**
 * A backfill represents an update to historical usage data, adding or replacing events in a timeframe.
 */
export class Backfill extends SpeakeasyBase {
    /**
     * If in the future, the time at which the backfill will automatically close. If in the past, the time at which the backfill was closed.
     */
    @SpeakeasyMetadata()
    @Expose({ name: "close_time" })
    @Transform(({ value }) => new Date(value), { toClassOnly: true })
    closeTime: Date;

    @SpeakeasyMetadata()
    @Expose({ name: "created_at" })
    @Transform(({ value }) => new Date(value), { toClassOnly: true })
    createdAt: Date;

    /**
     * The customer ID this backfill is scoped to. If null, this backfill is not scoped to a single customer.
     */
    @SpeakeasyMetadata()
    @Expose({ name: "customer_id" })
    customerId?: string;

    @SpeakeasyMetadata()
    @Expose({ name: "id" })
    id: string;

    /**
     * The time at which this backfill was reverted.
     */
    @SpeakeasyMetadata()
    @Expose({ name: "reverted_at" })
    @Transform(({ value }) => new Date(value), { toClassOnly: true })
    revertedAt?: Date;

    /**
     * The status of the backfill.
     */
    @SpeakeasyMetadata()
    @Expose({ name: "status" })
    status: BackfillStatus;

    @SpeakeasyMetadata()
    @Expose({ name: "timeframe_end" })
    @Transform(({ value }) => new Date(value), { toClassOnly: true })
    timeframeEnd: Date;

    @SpeakeasyMetadata()
    @Expose({ name: "timeframe_start" })
    @Transform(({ value }) => new Date(value), { toClassOnly: true })
    timeframeStart: Date;
}
